---
title: "Sampling from a Normal Distribution"
author: "C. Gon"
date: "2023-03-31"
categories: [news, code, analysis]
image: "image.jpg"
---

# Sampling from a Normal Distribution

```{python}
# # First, import the necessary libraries
# import numpy as np
# import matplotlib.pyplot as plt
# from ipywidgets import interact, FloatSlider, IntSlider

# # Then, define the function that you want to interact with
# def plot_distribution(significance, sampling_error, variability, population_size):
#     # Determine the sample size based on the significance, sampling error, and variability
#     # Here, I'm using a simple formula for sample size calculation, you can replace it with your own formula
#     z_score = 1.96
#     sample_size = int((np.square(z_score)*variability*(1-variability))/np.square(sampling_error))

#     # Adjust sample size for finite population
#     adjusted_sample_size = int(sample_size / (1 + (sample_size - 1) / population_size))

#     # Create a normally distributed sample with the given parameters
#     sample = np.random.normal(loc=significance, scale=sampling_error, size=adjusted_sample_size)

#     # Create the histogram of the sample
#     plt.hist(sample, bins='auto')

#     # Show the plot
#     plt.show()

#     return adjusted_sample_size

# # Set up the interaction
# interact(plot_distribution, 
#          significance=FloatSlider(value=0.5, min=0, max=1, step=0.01),
#          sampling_error=FloatSlider(value=0.05, min=0, max=1, step=0.01),
#          variability=FloatSlider(value=0.5, min=0, max=1, step=0.01),
#          population_size=IntSlider(value=1000, min=1, max=100000, step=1))

```

# Sampling Calculator


```{python}
# import math

# def calculate_sample_size(population_size, precision, sampling_error, variance):
#     z_square = (1.96)**2  # Z-value for a 95% confidence level is 1.96
#     e_square = (sampling_error / 100) ** 2
#     p = variance / 100
#     q = 1 - p

#     # Calculate Cochran's sample size
#     cochran_n = (z_square * p * q) / e_square

#     # Apply finite population correction
#     sample_size = cochran_n / (1 + ((cochran_n - 1) / population_size))

#     return math.ceil(sample_size)

# # Example inputs
# population_size = 10000
# precision = 0.05
# sampling_error = 5
# variance = 50

# sample_size = calculate_sample_size(population_size, precision, sampling_error, variance)
# print(f"Required sample size: {sample_size}")



```